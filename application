package com.example.weather.application;

import com.example.weather.infrastructure.api.WeatherApiClient;
import com.example.weather.infrastructure.api.dto.WeatherForecastRequest;
import com.example.weather.infrastructure.mapper.WeatherForecastMapper;
import com.example.weather.domain.model.WeatherData;

import java.io.IOException;

public class WeatherForecastUseCase {

    private final WeatherApiClient apiClient;
    private final WeatherForecastMapper mapper;

    public WeatherForecastUseCase(WeatherApiClient apiClient, WeatherForecastMapper mapper) {
        this.apiClient = apiClient;
        this.mapper = mapper;
    }

    public WeatherData getForecast(WeatherForecastRequest request) {
        String key = request.getApiKey();
        if (key == null || key.isEmpty()) {
            throw new IllegalStateException("WEATHER_API_KEY not set");
        }

        try {
            var response = apiClient.fetchForecast(request);
            if (response == null || response.forecast == null || response.forecast.forecastDays.isEmpty()) {
                return null;
            }
            return mapper.toWeatherData(response.forecast.forecastDays.get(0));
        } catch (IOException e) {
            throw new RuntimeException("Failed to fetch forecast for " + request.getCity(), e);
        }
    }
}

package com.example.weather.domain.model;

import lombok.*;

@Getter
@Builder
public class WeatherData {
    private final double minTemp;
    private final double maxTemp;
    private final double humidity;
    private final double windSpeed;
    private final String windDir;
}
package com.example.weather.infrastructure.api;

import com.example.weather.infrastructure.api.dto.WeatherForecastResponse;
import retrofit2.Call;
import retrofit2.http.GET;
import retrofit2.http.Query;

public interface WeatherApi {
    @GET("forecast.json")
    Call<WeatherForecastResponse> getForecast(
            @Query("key") String apiKey,
            @Query("q") String city,
            @Query("dt") String date
    );
}
package com.example.weather.infrastructure.api;

import com.example.weather.infrastructure.api.dto.WeatherForecastRequest;
import com.example.weather.infrastructure.api.dto.WeatherForecastResponse;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;

import java.io.IOException;

public class WeatherApiClient {

    private final static String BASE_URL = "http://api.weatherapi.com/v1/";
    private final WeatherApi api = new Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(WeatherApi.class);


    public WeatherForecastResponse fetchForecast(WeatherForecastRequest r) throws IOException {
        return api.getForecast(r.getApiKey(), r.getCity(), r.getDate())
                .execute()
                .body();
    }
}

package com.example.weather.infrastructure.config;

import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;

public class WeatherConfig {
    private static final String CONFIG_FILE = "config.properties";
    private final Properties props = new Properties();

    public WeatherConfig() {
        try (InputStream input = getClass().getClassLoader().getResourceAsStream(CONFIG_FILE)) {
            if (input == null) {
                throw new RuntimeException("Config file not found: " + CONFIG_FILE);
            }
            props.load(input);
        } catch (IOException e) {
            throw new RuntimeException("Failed to load config file", e);
        }
    }

    public List<String> getCities() {
        String cities = props.getProperty("cities");
        return Arrays.asList(cities.split(","));
    }
}
package com.example.weather.infrastructure.mapper;

import com.example.weather.infrastructure.api.dto.WeatherForecastResponse;
import com.example.weather.domain.model.WeatherData;
import org.mapstruct.*;
import org.mapstruct.factory.Mappers;

import java.util.Map;
import java.util.stream.Collectors;

@Mapper
public interface WeatherForecastMapper {
    WeatherForecastMapper INSTANCE = Mappers.getMapper(WeatherForecastMapper.class);

    @Mapping(target = "minTemp", source = "day.minTemp")
    @Mapping(target = "maxTemp", source = "day.maxTemp")
    @Mapping(target = "humidity", source = "day.avgHumidity")
    @Mapping(target = "windSpeed", source = "day.maxWindKph")
    @Mapping(target = "windDir", source = ".", qualifiedByName = "getWindDir")

    WeatherData toWeatherData(WeatherForecastResponse.ForecastDay forecastDay);

    @Named("getWindDir")
    default String getWindDir(WeatherForecastResponse.ForecastDay forecastDay) {

        return forecastDay.hours.stream()
                .collect(Collectors.groupingBy(h -> h.windDir, Collectors.counting()))
                .entrySet()
                .stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse("N/A");
    }
}
package com.example.weather.infrastructure.api.dto;

import lombok.Builder;
import lombok.Getter;

import java.time.LocalDate;

@Getter
@Builder
public class WeatherForecastRequest {
    @Builder.Default
    private final String date = LocalDate.now().plusDays(1).toString();
    @Builder.Default
    private final String apiKey = System.getenv("WEATHER_API_KEY");
    private final String city;
}
package com.example.weather.infrastructure.api.dto;

import com.google.gson.annotations.SerializedName;

import java.util.List;

public class WeatherForecastResponse {
    public Forecast forecast;

    public static class Forecast {
        @SerializedName("forecastday")
        public List<ForecastDay> forecastDays;
    }

    public static class ForecastDay {
        public DayInfo day;
        @SerializedName("hour")
        public List<HourInfo> hours;
    }

    public static class DayInfo {
        @SerializedName("maxtemp_c")
        public double maxTemp;
        @SerializedName("mintemp_c")
        public double minTemp;
        @SerializedName("maxwind_kph")
        public double maxWindKph;
        @SerializedName("avghumidity")
        public double avgHumidity;
    }

    public static class HourInfo {
        @SerializedName("wind_dir")
        public String windDir;
    }

}
package com.example.weather.infrastructure.mapper;

import com.example.weather.infrastructure.api.dto.WeatherForecastResponse;
import com.example.weather.domain.model.WeatherData;
import org.mapstruct.*;
import org.mapstruct.factory.Mappers;

import java.util.Map;
import java.util.stream.Collectors;

@Mapper
public interface WeatherForecastMapper {
    WeatherForecastMapper INSTANCE = Mappers.getMapper(WeatherForecastMapper.class);

    @Mapping(target = "minTemp", source = "day.minTemp")
    @Mapping(target = "maxTemp", source = "day.maxTemp")
    @Mapping(target = "humidity", source = "day.avgHumidity")
    @Mapping(target = "windSpeed", source = "day.maxWindKph")
    @Mapping(target = "windDir", source = ".", qualifiedByName = "getWindDir")

    WeatherData toWeatherData(WeatherForecastResponse.ForecastDay forecastDay);

    @Named("getWindDir")
    default String getWindDir(WeatherForecastResponse.ForecastDay forecastDay) {

        return forecastDay.hours.stream()
                .collect(Collectors.groupingBy(h -> h.windDir, Collectors.counting()))
                .entrySet()
                .stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse("N/A");
    }
}
package com.example.weather.infrastructure.output;

import com.example.weather.domain.model.WeatherData;
import de.vandermeer.asciitable.AsciiTable;
import de.vandermeer.asciitable.CWC_LongestLine;
import de.vandermeer.skb.interfaces.transformers.textformat.TextAlignment;

import java.util.List;

public class WeatherReportPrinter {

    public void generateWeatherReport(List<String> cities, List<WeatherData> dataList) {
        AsciiTable table = new AsciiTable();
        table.addRule();
        table.addRow("City", "Minimum Temperature (°C)", "Maximum Temperature (°C)", "Humidity (%)", "Wind Speed (kph)", "Wind Direction");
        table.addRule();

        for (int i = 0; i < cities.size(); i++) {
            table.addRow(buildRow(cities.get(i),dataList.get(i)));
            table.addRule();
        }
        table.setTextAlignment(TextAlignment.CENTER);
        table.getRenderer().setCWC(new CWC_LongestLine());
        table.setPaddingLeftRight(1);
        System.out.println(table.render());
    }

    private Object[] buildRow(String city, WeatherData data) {
        if (data != null) {
            return new Object[]{
                    city,
                    data.getMinTemp(),
                    data.getMaxTemp(),
                    data.getHumidity(),
                    data.getWindSpeed(),
                    data.getWindDir()
            };
        } else {
            return new Object[]{city, "N/A", "N/A", "N/A", "N/A", "N/A"};
        }
    }
}
package com.example.weather;

import com.example.weather.application.WeatherForecastUseCase;
import com.example.weather.domain.model.WeatherData;
import com.example.weather.infrastructure.api.WeatherApiClient;
import com.example.weather.infrastructure.config.WeatherConfig;
import com.example.weather.infrastructure.mapper.WeatherForecastMapper;
import com.example.weather.infrastructure.output.WeatherReportPrinter;
import com.example.weather.infrastructure.api.dto.WeatherForecastRequest;

import java.util.List;

public class WeatherApp {
    public static void main(String[] args) {
        List<String> cities = new WeatherConfig().getCities();

        WeatherForecastMapper mapper = WeatherForecastMapper.INSTANCE;
        WeatherApiClient apiClient = new WeatherApiClient();
        WeatherForecastUseCase service = new WeatherForecastUseCase(apiClient, mapper);
        WeatherReportPrinter reportService = new WeatherReportPrinter();

        List<WeatherData> results = cities.stream()
                .map(city -> service.getForecast(WeatherForecastRequest.builder().city(city).build()))
                .toList();

        reportService.generateWeatherReport(cities, results);
    }
}
