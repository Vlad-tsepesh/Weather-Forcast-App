package com.example.weather.application.port;

import java.util.List;

public interface HeaderExtractor {
    List<String> extractHeaders(Class<?> clazz);
}
package com.example.weather.application.port;

import java.util.List;

public interface RowExtractor {
    List<String> extractRow(Object row);
}
package com.example.weather.application.port;

import java.util.List;

public interface TableRenderer {
    void render(List<String> headers, List<List<String>> rows);
}
package com.example.weather.application.port;

import com.example.weather.domain.model.WeatherData;

import java.time.LocalDate;

public interface WeatherForecastProvider {
    WeatherData fetchForecast(String city, LocalDate date);
}
package com.example.weather.application.port;

import java.util.List;

public interface WeatherReportWriter {
    void writeReport(List<?> reportRows);
}
package com.example.weather.application.usecase;

import com.example.weather.application.port.WeatherForecastProvider;
import com.example.weather.application.port.WeatherReportWriter;
import com.example.weather.domain.model.WeatherData;
import com.example.weather.domain.model.WeatherReportRow;
import com.example.weather.domain.service.WeatherReportBuilder;
import lombok.RequiredArgsConstructor;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@RequiredArgsConstructor
public class WeatherForecastUseCase {

    private final WeatherForecastProvider forecastProvider;
    private final WeatherReportBuilder reportBuilder;
    private final WeatherReportWriter reportWriter;


    public void runForecastForTomorrow(List<String> cities) {
        LocalDate tomorrow = LocalDate.now().plusDays(1);
        List<WeatherReportRow> reportRows = new ArrayList<>();

        for (String city : cities) {
            WeatherData weatherData = forecastProvider.fetchForecast(city, tomorrow);
            reportRows.addAll(reportBuilder.buildRows(city, weatherData));
        }

        reportWriter.writeReport(reportRows);
    }

}

package com.example.weather.domain.annotation;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
    String value();
}
package com.example.weather.domain.model;


import lombok.Builder;

import java.util.List;

@Builder
public record WeatherData(List<ForecastDay> forecastDays) {
    @Builder
        public record ForecastDay(String date, DayInfo day, List<HourInfo> hours, double windDir) {
    }

    @Builder
        public record DayInfo(double minTemp, double maxTemp, double avgHumidity, double maxWindKph) {
    }

    @Builder
        public record HourInfo(String windDir) {
    }
}
package com.example.weather.domain.model;

import com.example.weather.domain.annotation.Column;
import lombok.Builder;

@Builder
public record WeatherReportRow(@Column("City") String city,
                               @Column("Date") String date,
                               @Column("Minimum Temperature (°C)") double minTemp,
                               @Column("Maximum Temperature (°C)") double maxTemp,
                               @Column("Humidity (%)") double humidity,
                               @Column("Wind Speed (kph)") double windSpeed,
                               @Column("Wind Direction") String windDirection) {
}
package com.example.weather.domain.service;

import com.example.weather.domain.model.WeatherData;
import com.example.weather.domain.model.WeatherReportRow;

import java.util.List;

public class WeatherReportBuilder {

    private final WindAnalyzer windAnalyzer;

    public WeatherReportBuilder(WindAnalyzer windAnalyzer) {
        this.windAnalyzer = windAnalyzer;
    }

    public WeatherReportRow buildRow(String city, WeatherData.ForecastDay day) {
        return WeatherReportRow.builder()
                .city(city)
                .date(day.date())
                .minTemp(day.day().minTemp())
                .maxTemp(day.day().maxTemp())
                .humidity(day.day().avgHumidity())
                .windSpeed(day.day().maxWindKph())
                .windDirection(windAnalyzer.mostCommonDirection(day.hours()))
                .build();
    }

    public List<WeatherReportRow> buildRows(String city, WeatherData weatherData) {
        return weatherData.forecastDays().stream()
                .map(day -> buildRow(city, day))
                .toList();
    }
}
package com.example.weather.domain.service;

import com.example.weather.domain.model.WeatherData;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class WindAnalyzer {

    public String mostCommonDirection(List<WeatherData.HourInfo> hours) {
        return hours.stream()
                    .collect(Collectors.groupingBy(WeatherData.HourInfo::windDir, Collectors.counting()))
                    .entrySet()
                    .stream()
                    .max(Map.Entry.comparingByValue())
                    .map(Map.Entry::getKey)
                    .orElse("N/A");
    }
}
package com.example.weather.infrastructure.api.dto;

import com.google.gson.annotations.SerializedName;

import java.util.List;

public class WeatherForecastResponse {
    public Forecast forecast;

    public static class Forecast {
        @SerializedName("forecastday")
        public List<ForecastDay> forecastDays;
    }

    public static class ForecastDay {
        public String date;
        public DayInfo day;
        @SerializedName("hour")
        public List<HourInfo> hours;
    }

    public static class DayInfo {
        @SerializedName("maxtemp_c")
        public double maxTemp;
        @SerializedName("mintemp_c")
        public double minTemp;
        @SerializedName("maxwind_kph")
        public double maxWindKph;
        @SerializedName("avghumidity")
        public double avgHumidity;
    }

    public static class HourInfo {
        @SerializedName("wind_dir")
        public String windDir;
    }

}
package com.example.weather.infrastructure.api.exception;

public class NoForecastAvailableException extends RuntimeException {
    public NoForecastAvailableException(String city) {
        super("No forecast available for city: " + city);
    }
}
package com.example.weather.infrastructure.api.exception;

public class WeatherApiException extends RuntimeException {
    public WeatherApiException(String message) {
        super(message);
    }

    public WeatherApiException(String message, Throwable cause) {
        super(message, cause);
    }
}
package com.example.weather.infrastructure.api;

import com.example.weather.infrastructure.api.dto.WeatherForecastResponse;
import retrofit2.Call;
import retrofit2.http.GET;
import retrofit2.http.Query;

public interface WeatherApi {
    @GET("forecast.json")
    Call<WeatherForecastResponse> getForecast(
            @Query("key") String apiKey,
            @Query("q") String city,
            @Query("dt") String date
    );
}
package com.example.weather.infrastructure.api;

import com.example.weather.domain.model.WeatherData;
import com.example.weather.application.port.WeatherForecastProvider;
import com.example.weather.infrastructure.api.dto.WeatherForecastResponse;
import com.example.weather.infrastructure.api.exception.NoForecastAvailableException;
import com.example.weather.infrastructure.api.exception.WeatherApiException;
import com.example.weather.infrastructure.config.WeatherConfig;
import com.example.weather.infrastructure.mapper.WeatherForecastMapper;
import lombok.RequiredArgsConstructor;

import java.io.IOException;
import java.time.LocalDate;
import java.util.Optional;

@RequiredArgsConstructor
public class WeatherApiClient implements WeatherForecastProvider {

    private final WeatherConfig config;
    private final WeatherApi api;
    private final WeatherForecastMapper mapper;

    public WeatherData fetchForecast(String city, LocalDate date ) {
        Optional<WeatherForecastResponse> responseOptional = fetchRowForecast(city, date);
        var forecast = responseOptional
                .map(response -> response.forecast)
                .orElseThrow(() ->
                        new NoForecastAvailableException(city));

        return mapper.toWeatherData(forecast);
    }


    public Optional<WeatherForecastResponse> fetchRowForecast(String city, LocalDate date) {
        try {
            var responseDto = api.getForecast(config.getApiKey(), city, date.toString())
                    .execute();

            return Optional.ofNullable(responseDto.body());

        } catch (IOException e) {
            throw new WeatherApiException("Failed to fetch forecast for " + city, e);
        }
    }
}
package com.example.weather.infrastructure.config;

import com.example.weather.infrastructure.api.WeatherApi;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;

public class RetrofitFactory {

    private final static String BASE_URL = "http://api.weatherapi.com/v1/";

    public static WeatherApi createWeatherApi() {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(BASE_URL)
                .addConverterFactory(GsonConverterFactory.create())
                .build();

        return retrofit.create(WeatherApi.class);
    }
}
package com.example.weather.infrastructure.config;

import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;

public class WeatherConfig {
    private static final String CONFIG_FILE = "config.properties";
    private final Properties props = new Properties();

    public WeatherConfig() {
        try (InputStream input = getClass().getClassLoader().getResourceAsStream(CONFIG_FILE)) {
            if (input == null) {
                throw new RuntimeException("Config file not found: " + CONFIG_FILE);
            }
            props.load(input);
        } catch (IOException e) {
            throw new RuntimeException("Failed to load config file", e);
        }
    }

    public List<String> getCities() {
        String cities = props.getProperty("cities");
        return Arrays.asList(cities.split(","));
    }

    public String getApiKey() {
        return props.getProperty("WEATHER_API_KEY");
    }
}
package com.example.weather.infrastructure.extractor;

import com.example.weather.application.port.HeaderExtractor;
import com.example.weather.domain.annotation.Column;
import org.apache.commons.lang3.reflect.FieldUtils;

import java.util.List;
import java.util.stream.Collectors;

public class ColumnAnnotationHeaderExtractor implements HeaderExtractor {

    @Override
    public List<String> extractHeaders(Class<?> clazz) {
        return FieldUtils.getFieldsListWithAnnotation(clazz, Column.class).stream()
                .map(f -> f.getAnnotation(Column.class).value())
                .collect(Collectors.toList());
    }
}
package com.example.weather.infrastructure.extractor;

import com.example.weather.application.port.RowExtractor;
import com.example.weather.domain.annotation.Column;
import org.apache.commons.lang3.reflect.FieldUtils;

import java.util.List;
import java.util.stream.Collectors;

public class ReflectionRowExtractor implements RowExtractor {
    public List<String> extractRow(Object row) {
        Class<?> clazz = row.getClass();
        return FieldUtils.getFieldsListWithAnnotation(clazz, Column.class).stream()
                .map(f -> {
                    f.setAccessible(true);
                    try {
                        Object val = f.get(row);
                        return val != null ? val.toString() : "";
                    } catch (IllegalAccessException e) {
                        return "";
                    }
                })
                .collect(Collectors.toList());
    }
}
package com.example.weather.infrastructure.mapper;

import com.example.weather.domain.model.WeatherData;
import com.example.weather.infrastructure.api.dto.WeatherForecastResponse;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

@Mapper
public interface WeatherForecastMapper {
    WeatherForecastMapper INSTANCE = Mappers.getMapper(WeatherForecastMapper.class);

    @Mapping(target = "forecastDays", source = "forecastDays")
    WeatherData toWeatherData(WeatherForecastResponse.Forecast forecast);
}
package com.example.weather.infrastructure.output;

import com.example.weather.application.port.TableRenderer;
import de.vandermeer.asciitable.AsciiTable;
import de.vandermeer.asciitable.CWC_LongestLine;
import de.vandermeer.skb.interfaces.transformers.textformat.TextAlignment;

import java.util.List;

public class AsciiTableRenderer implements TableRenderer {

    @Override
    public void render(List<String> headers, List<List<String>> rows) {
        AsciiTable table = new AsciiTable();
        table.addRule();
        table.addRow(headers);
        table.addRule();

        for (List<String> row : rows) {
            table.addRow(row);
            table.addRule();
        }

        table.setTextAlignment(TextAlignment.CENTER);
        table.getRenderer().setCWC(new CWC_LongestLine());
        table.setPaddingLeftRight(1);

        System.out.println(table.render());
    }
}
package com.example.weather.infrastructure.output;

import com.example.weather.application.port.HeaderExtractor;
import com.example.weather.application.port.RowExtractor;
import com.example.weather.application.port.TableRenderer;
import com.example.weather.application.port.WeatherReportWriter;
import lombok.RequiredArgsConstructor;

import java.util.List;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class WeatherReportPrinter implements WeatherReportWriter {

    private final HeaderExtractor headerExtractor;
    private final RowExtractor rowExtractor;
    private final TableRenderer tableRenderer;


    public void writeReport(List<?> reportRows) {
        if (reportRows.isEmpty()) return;

        List<String> headers = extractHeaders(reportRows);
        List<List<String>> rows = extractRows(reportRows);

        tableRenderer.render(headers, rows);
    }

    private List<String> extractHeaders(List<?> reportRows) {
        return headerExtractor.extractHeaders(reportRows.get(0).getClass());
    }

    private List<List<String>> extractRows(List<?> reportRows) {
        return reportRows.stream()
                .map(rowExtractor::extractRow)
                .collect(Collectors.toList());
    }
}
package com.example.weather;

import com.example.weather.application.port.HeaderExtractor;
import com.example.weather.application.port.RowExtractor;
import com.example.weather.application.port.TableRenderer;
import com.example.weather.application.port.WeatherForecastProvider;
import com.example.weather.application.port.WeatherReportWriter;
import com.example.weather.application.usecase.WeatherForecastUseCase;
import com.example.weather.domain.service.WeatherReportBuilder;
import com.example.weather.domain.service.WindAnalyzer;
import com.example.weather.infrastructure.api.WeatherApiClient;
import com.example.weather.infrastructure.config.RetrofitFactory;
import com.example.weather.infrastructure.config.WeatherConfig;
import com.example.weather.infrastructure.extractor.ColumnAnnotationHeaderExtractor;
import com.example.weather.infrastructure.extractor.ReflectionRowExtractor;
import com.example.weather.infrastructure.mapper.WeatherForecastMapper;
import com.example.weather.infrastructure.output.AsciiTableRenderer;
import com.example.weather.infrastructure.output.WeatherReportPrinter;

public class WeatherApp {
    public static void main(String[] args) {
        WeatherConfig config = new WeatherConfig();
        WeatherForecastMapper mapper = WeatherForecastMapper.INSTANCE;
        WeatherForecastProvider apiClient = new WeatherApiClient(config, RetrofitFactory.createWeatherApi(), mapper);
        RowExtractor rowExtractor = new ReflectionRowExtractor();
        HeaderExtractor headerExtractor = new ColumnAnnotationHeaderExtractor();
        TableRenderer renderer = new AsciiTableRenderer();
        WindAnalyzer windAnalyzer = new WindAnalyzer();
        WeatherReportBuilder reportBuilder = new WeatherReportBuilder(windAnalyzer);
        WeatherReportWriter reportWriter = new WeatherReportPrinter(headerExtractor, rowExtractor, renderer);
        WeatherForecastUseCase useCase = new WeatherForecastUseCase(apiClient, reportBuilder, reportWriter);

        useCase.runForecastForTomorrow(config.getCities());
    }
}


non spring boot project,